---
title: NodeJS 读书笔记 第5章
date: 2018-07-02 00:16:51
tags: [NodeJS]
description: 内存控制
categories: NodeJS
---

## javaScript高级程序设计 补充

### Js的垃圾回收机制和内存控制
在《JavaScript高级程序设计》（第三版）里也有提到了js的垃圾回收机制和内存回收问题，这里简单的回想一下：

我们知道，js和java的一个共同点就是有自己的垃圾回收机制，所以他们不用像C/C++程序员一样在编写代码的时候去关心内存的分配与释放的问题。关于js的垃圾回收机制，主要有以下两种：

* 标记清除： 
这个很容易理解，就是当你在函数内声明一个变量，那么在函数执行的时候，就将该变量进行标记，标记为进入，函数执行完毕就标记为离开，进入标记的是不可以被回收的
* 引用计数：
更简单的，就是一个变量被使用的次数，用到一次就加一，数目小于多少的就给予清除
那么如何管理内存呢？

前面也说了，因为有自动的垃圾回收机制，所以程序员不用去操心内存管理的问题，但是要注意的一点就是，js的可用内存是很小的，或者说是远远小于桌面程序的可使用内存（这个后面再说），所以为了确保占用最少的内存可以让页面获得更好地性能，最佳方式就是为执行中的代码只保存必要的数据，一旦数据不再有用，就将其释放（比如设置其值为null来释放引用），这样做的目的是解除变量的引用从而使垃圾收集机制在下次运行时将其回收（垃圾回收机制是按照固定的时间间隔或者预设的时间进行处理的，所以这个时间的长短也要考虑性能问题）

__________________

海量请求+长时间运行 -> 内存控制 -> 一切资源高效循环利用

## V8的垃圾回收机制与内存限制

在Node中通过JavaScript使用内存时，只能使用部分内存（64位系统下约1.4GB，32位系统下约为0.7GB）。

在V8中，所有的JavaScript对象都是通过堆来进行分配的，当申请的堆空闲内存不够分配新的对象，将继续申请堆内存，直到堆得大小超过V8的限制为止。

### 为什么V8要限制堆得大小？

* V8最初为浏览器设计，不太可能遇到用大量内存的场景。
* V8的垃圾回收机制限制。（1.5GB的垃圾回收堆内存，需要大约50毫秒以上，这使得应用性能和响应能力会直线下降）

### 突破V8限制：

```bash
$ node --max-old-space-size = 1700 (单位MB) or 

$ node --max-new-space-size =1024 (单位KB)
```

### V8的垃圾回收机制 ---- 分代式垃圾回收机制

查看垃圾回收机制

```bash
$ node --trace_gc -e "var a = [];for (var i=0; i<1000000; i++) a.push(new Array(100));" > gc.log
```

## 高效使用内存

* 了解作用域
* 了解闭包

### 无法立即回收的内存有：

* 闭包
* 全局变量引用

因此，要小心此类变量的无限制添加

## 内存指标

会存在一些我们认为会回收但是却没有被回收的对象，这会导致内存占用无限增长。一旦增长达到V8内存限制，将会得到内存溢出错误，进而导致进程退出。

### 查看内存使用情况
```bash
$node >process.memoryUsage() {
　　　　　　{

　　　　　　　rss （resident set size 进程的常驻内存部分）：132852672, （除此外，内存其余部分在交换区（swap）或文件系统（filesystem）中）

　　　　　　   heapTotal（堆中总共申请的内存量） ：6131200,

　　　　　　   heapUsed（目前堆中使用中的内存量）：2757120,

　　　　　　}
}
```

### 查看系统内存占用

```bash
$node >os.totalmem()  “系统的总内存”

$node >os.freemem() “系统的闲置内存”
```
### 堆外内存

受V8的垃圾回收限制的主要是V8的堆内存。

## 内存泄漏

造成内存泄漏的原因：

* 缓存

* 队列消费不及时

* 作用域未释放

## 内存泄漏排查

使用常见工具：

* node-heapdump

* node-memwatch

6. 大内存应用

Node中提供stream模块用于处理大文件，分为可读和可写两种，Node中大部分模块都具有stream的应用如：

fs.createReadStream()、fs.createWriteStream()，可以避免由于V8内存限制不能通过fs.readFile()或fs.writeFile()操作大文件。

```javascript
let reader = fs.createReadStream('in.txt')
let writer = fs.createReadStream('out.txt')
reader.pipe(writer)
```


